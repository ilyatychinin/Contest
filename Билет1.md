## 1. Программа на языке C++

Программа на языке C++ состоит из исходного кода, который обычно разделён на несколько файлов для удобства организации и поддержки.

### Исходный код:
- **Файлы `.cpp`** содержат исходный код на языке C++. Они используются для написания логики программы, включая функции, классы и переменные.
- **Файлы `.h` (заголовочные)** содержат объявления функций, классов, констант и других элементов, которые используются в нескольких `.cpp` файлах.

### Почему код разделяют на `.cpp` и `.h` файлы?
- **Модульность**: Заголовочные файлы позволяют разделить интерфейс (объявления) и реализацию (код). Это упрощает чтение и поддержку кода.
- **Повторное использование**: Заголовочные файлы можно включать в несколько `.cpp` файлов, что позволяет избежать дублирования кода.
- **Ускорение компиляции**: При изменении одного `.cpp` файла перекомпилируется только он, а не вся программа.

### Структура программы:
1. Программа начинается с функции `main()`, которая является точкой входа.
2. Исходный код может быть разделён на несколько файлов, которые компилируются и линкуются вместе.
3. **Return в `main`**: Возвращает код завершения программы. Например, `return 0;` означает успешное завершение. В стандарте C++ начиная с C++11, если функция `main` завершилась без явного вызова `return`, считается, что она возвращает `0` автоматически.

### Директивы препроцессора:
- `#include` — подключает заголовочные файлы. Например, `#include <iostream>` подключает стандартную библиотеку ввода-вывода.
- `#define` — определяет макросы. Например, `#define PI 3.14`.
- `#ifdef`, `#ifndef`, `#endif` — условная компиляция, которая позволяет включать или исключать код в зависимости от условий.

### Подключение стороннего кода:
- **Через `#include`**: Используется для подключения заголовочных файлов.
- **Циклическое подключение**: Возникает, когда два или более заголовочных файла включают друг друга напрямую или косвенно. Это приводит к бесконечной рекурсии при обработке директив `#include`, что вызывает ошибки компиляции.
  - Пример циклического подключения:
    ```cpp
    // FileA.h
    #include "FileB.h"
    // FileB.h
    #include "FileA.h"
    ```
  - Проблема: Компилятор зацикливается, пытаясь включить `FileA.h` и `FileB.h` друг в друга.
- **Ромбовидное подключение**: Возникает, когда один заголовочный файл включается через несколько путей в иерархии включения. Это приводит к множественному включению одного и того же файла, что может вызвать ошибки компиляции (например, повторное определение символов).
- **Как работают `#ifndef`/`#define`/`#endif`**: Эти директивы создают "стражей включения" (include guards). Они проверяют, был ли файл уже включен, и если да, то пропускают его повторное включение.

## 2. Сборка программы

### Этапы сборки:
1. **Препроцессинг**: Обработка директив, таких как `#include` и `#define`. Препроцессор подключает заголовочные файлы и заменяет макросы.
2. **Компиляция**: Преобразование исходного кода (`.cpp`) в объектный код (машинный код). Компилятор проверяет синтаксис и семантику кода.
   - **Отличия компиляции от интерпретации**:
     - **Компиляция**: Весь код преобразуется в машинный код перед выполнением. Это быстрее, но требует отдельного этапа компиляции.
     - **Интерпретация**: Код выполняется построчно без предварительной компиляции. Это медленнее, но позволяет быстрее тестировать изменения.
   - **Существующие компиляторы C++**:
     - **GCC** (GNU Compiler Collection) — популярный компилятор с открытым исходным кодом.
     - **Clang** — часть проекта LLVM, известен своей скоростью и качеством диагностики ошибок.
     - **MSVC** (Microsoft Visual C++) — компилятор от Microsoft, используется в Visual Studio.
3. **Линковка**: Объединение объектных файлов и библиотек в исполняемый файл. Линкер разрешает ссылки между модулями.

### Артефакты сборки:
- **Исполняемый файл**:
  - Это конечный результат компиляции и линковки вашего проекта.
  - Содержит машинный код, который может быть непосредственно выполнен операционной системой.
  - Примеры: `.exe` (Windows), без расширения или с расширением `.out` (Linux/macOS).
- **Статическая библиотека**:
  - Это коллекция скомпилированных объектных файлов (`.o` или `.obj`), объединенных в один файл.
  - Статически линкуется с исполняемым файлом на этапе компиляции.
  - **Преимущества**:
    - Все необходимое включается в исполняемый файл, что упрощает распространение.
    - Нет зависимости от внешних библиотек во время выполнения.
  - **Недостатки**:
    - Увеличивает размер исполняемого файла.
    - Обновление библиотеки требует перекомпиляции программы.
  - Примеры: `.lib` (Windows), `.a` (Linux/macOS).
- **Динамическая библиотека**:
  - Это отдельный файл, содержащий код, который может быть загружен и использован программой во время выполнения.
  - Динамически линкуется с исполняемым файлом.
  - **Преимущества**:
    - Уменьшает размер исполняемого файла.
    - Позволяет обновлять библиотеку без перекомпиляции основной программы.
  - **Недостатки**:
    - Программа зависит от наличия библиотеки в системе.
    - Может возникнуть проблема совместимости версий.
  - Примеры: `.dll` (Windows), `.so` (Linux), `.dylib` (macOS).

## 3. Запуск программы

### Процесс запуска программы (без IDE):
1. **Компиляция**: Исходный код (`.cpp` файлы) компилируется в объектные файлы (`.o` или `.obj`). Например, с помощью команды `g++ -c main.cpp` создаётся объектный файл `main.o`.
2. **Линковка**: Объектные файлы и библиотеки объединяются в исполняемый файл. Например, `g++ main.o -o program` создаёт исполняемый файл `program`.
3. **Запуск**: Исполняемый файл запускается через командную строку. Например, `./program` запускает программу в Unix-подобных системах, а `program.exe` — в Windows.

### Пути поиска динамических библиотек:
- Динамические библиотеки (например, `.so` в Linux или `.dll` в Windows) ищутся в стандартных путях, таких как `/usr/lib` в Linux или `C:\Windows\System32` в Windows.
- Можно указать дополнительные пути с помощью переменных окружения, например, `LD_LIBRARY_PATH` в Linux или `PATH` в Windows.

### Размещение программы в памяти:
- **Память программы в зависимости от разрядности**:
  - В **32-битных** системах программа может использовать до **4 ГБ** памяти.
  - В **64-битных** системах доступно значительно больше памяти (теоретически до **16 эксабайт**).
- **Стек (Stack)**:
  - Используется для хранения локальных переменных и управления вызовами функций.
  - Имеет ограниченный размер (обычно несколько мегабайт).
  - Работает по принципу LIFO (Last In, First Out).
- **Куча (Heap)**:
  - Используется для динамического выделения памяти (например, через `new` и `delete` в C++).
  - Размер кучи ограничен только доступной оперативной памятью.
  - Управление памятью в куче требует осторожности, чтобы избежать утечек памяти.
